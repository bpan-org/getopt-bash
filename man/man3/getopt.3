.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "STDIN 1"
.TH "getopt" 3 "2022-08-30" "md2man v0.1.0" "Bash Package Manager"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "GETOPT-BASH"
.IX Header "GETOPT-BASH"
Declarative getopt (long) parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #!/bin/bash
\&
\&    source getopt.bash "\e
\&    my\-app <options...> <arguents...>
\&
\&    See \*(Aqman my\-app\*(Aq for more help.
\&
\&    Options:
\&    \-\-
\&    b,bar       Bar bar bar
\&    q,quux=     Quux quux
\&
\&    xxx         Xxx xxx
\&    yyy=        Yyy yyy
\&
\&    help        Show help
\&    version     Print my\-app version
\&    "
\&
\&    getopt "$@"
\&    set \-\- "${args[@]}"
\&
\&    if $option_bar || $option_xxx; then
\&      echo \*(AqOptions:\*(Aq
\&      echo "quux = ${option_quux\-}"
\&      echo "yyy = ${option_yyy\-}"
\&      echo \*(AqArguments:\*(Aq
\&      printf "\- %s\en" "$@"
\&    fi
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Git has a little known, but very cool getopt parser built in. The Git command is:
.PP
.Vb 2
\&    git rev\-parse \-\-parseopt <command\-line\-args> \e
\&      <<<"<special\-format\-getopt\-spec\-text>"
.Ve
.PP
You pipe in a special format that looks like a help text describing the command. If you ask for \f(CW\*(C`\-\-help\*(C'\fR (or the parser fails to parse the options), it actually will print a slightly reformatted version of that spec.
.PP
This library makes the Git facility even more powerful and easy to use.
.SH "PARLANCE"
.IX Header "PARLANCE"
.IP "\(bu" 4
options (or opts)
.Sp
Options are the parameters like \f(CW\*(C`\-h\*(C'\fR, \f(CW\*(C`\-\-help\*(C'\fR, \f(CW\*(C`\-f <file\*(C'\fR>, \f(CW\*(C`\-\-file <file\*(C'\fR> or \f(CW\*(C`\-\-file=<file\*(C'\fR. Note that option names are case insensitive. ie >\-f\f(CW\*(C`and\*(C'\fR\-F` are diffent options.
.IP "\(bu" 4
arguments (or args)
.Sp
Arguments are the (zero or more) strings that (usually) follow the options.
.IP "\(bu" 4
long option
.Sp
An option of the form \f(CW\*(C`\-\-name\*(C'\fR. Two dashes and two or more letters in the name. An \f(CW\*(C`=\*(C'\fR or a space may be used to separate the option from its value. ie \f(CW\*(C`\-\-file=abc.txt\*(C'\fR or \f(CW\*(C`\-\-file abc.txt\*(C'\fR.
.IP "\(bu" 4
short option
.Sp
An option of the form \f(CW\*(C`\-n\*(C'\fR. A single dash and a single character for the name. If the option has a value, it is separated by a space: \f(CW\*(C`\-f abc.txt\*(C'\fR.
.IP "\(bu" 4
flag option
.Sp
Flag options never have a value parameter. The values returned by getopt-bash are \f(CW\*(C`false\*(C'\fR (default if the option is not present) and \f(CW\*(C`true\*(C'\fR if the option \fIis\fR present.
.IP "\(bu" 4
value option
.Sp
Value options always have a value parameter. This getopt-bash library returns the value specified or the empty string if it is not present in the parsed parameters.
.IP "\(bu" 4
dual option
.Sp
A dual option can be used alone like a flag option, or with a value.
.SH "USAGE"
.IX Header "USAGE"
The \f(CW\*(C`getopt\-bash\*(C'\fR library provides a single file \f(CW\*(C`lib/getopt.bash\*(C'\fR. If you \f(CW\*(C`source getopt.bash\*(C'\fR it provides a single function \f(CW\*(C`getopt\*(C'\fR. The \f(CW\*(C`getopt\*(C'\fR function expects a specially formatted spec string in its \s-1STDIN\s0 and the arguments you want to parse, passed in as arguments to the function.
.PP
It also checks for a special array variable called \f(CW\*(C`getopt\*(C'\fR (yes, you can have a variable and a function with the same name in Bash) that contains a number of configuration option pairs (descibed below).
.PP
The function will (by default) set each option in a variable called \f(CW\*(C`option_<option\-name\*(C'\fR> and will print any arguments to stdout.
.PP
\&\f(CW\*(C`_\*(C'\fR
.PP
Here's an example:
.PP
.Vb 7
\&    getopt=(
\&      default\-args  \-\-help
\&      debug\-opt     DEBUG
\&      args\-var      my_args
\&    )
\&    getopt "$@" <<<"$spec_string"
\&    echo "The \*(Aq\-\-foo\*(Aq option is \*(Aq$option_foo\*(Aq and the args are \*(Aq${my_args[*]}\*(Aq"
.Ve
.PP
\&\s-1NOTE:\s0 Bash has a builtin \f(CW\*(C`getopt\*(C'\fR command that doesn't do nearly as much. If you need to use the builtin in combination with this library, just use this command: \f(CW\*(C`builtin getopt ...\*(C'\fR for the builtin version.
.SS "\s-1THE GETOPT SPEC STRING FORMAT\s0"
.IX Subsection "THE GETOPT SPEC STRING FORMAT"
To get good at using getopt-bash you should run \f(CW\*(C`git help rev\-parse\*(C'\fR search for \f(CW\*(C`^PARSEOPT\*(C'\fR and read that entire section. The getopt-bash function uses \f(CW\*(C`git rev\-parse \-\-parseopt\*(C'\fR under the hood, but does a bunch of extra pre-processing and post-processing to make things really nice and simple.
.PP
The options section of the spec has these various combinations:
.PP
.Vb 5
\&    The options with \`string\` and \`number\` are enforced by getopt\-bash
\&    \-\-
\&    f,file=         Description of a value option (both short and long)
\&    help            Description of a flag option (long only)
\&    Q?              Description of a dual option (short only)
\&
\&    color=string    Value must be a string
\&    verbose?number  Value (if present) must be a number
.Ve
.PP
The getopt-bash library adds some additional features to the spec options syntax:
.PP
.Vb 4
\&    input=+         This option is required
\&    size=+number    Required and must be number
\&    style=@         May be used more than once
\&    color=+@string  Required, 1 or more times, must be string
.Ve
.PP
In \f(CW\*(C`git rev\-parse\*(C'\fR, there are 4 flag characters: '* = ? !`. The getopt-bash library adds:
.IP "\(bu" 4
\&\f(CW\*(C`+\*(C'\fR
.Sp
Option is required. This only makes sense for value options.
.IP "\(bu" 4
\&\f(CW\*(C`@\*(C'\fR
.Sp
Option may be specified multiple times. The getopt function puts the results in a Bash array variable.
.PP
In \f(CW\*(C`git rev\-parse\*(C'\fR you can specify a hint word to indicate in the help text what type of value (number, string, etc) is expected for a value option. The hint is not enforced.
.PP
By default, getopt-bash will enforce the following hints:
.IP "\(bu" 4
\&\f(CW\*(C`string\*(C'\fR or \f(CW\*(C`str\*(C'\fR
.Sp
Value should be a string.
.IP "\(bu" 4
\&\f(CW\*(C`number\*(C'\fR or \f(CW\*(C`num\*(C'\fR or \f(CW\*(C`int\*(C'\fR
.Sp
Value should be a number.
.IP "\(bu" 4
\&\f(CW1..10\fR
.Sp
Value should be a number in the range 1\-10.
.IP "\(bu" 4
\&\f(CW\*(C`file\*(C'\fR
.Sp
Value should be a file that exists.
.IP "\(bu" 4
\&\f(CW\*(C`dir\*(C'\fR
.Sp
Value should be a directory the exists.
.IP "\(bu" 4
\&\f(CW\*(C`path\*(C'\fR
.Sp
Value should be the path of a file or directory that exists.
.SS "\s-1CONFIGURATION\s0"
.IX Subsection "CONFIGURATION"
The \f(CW\*(C`getopt\*(C'\fR function has sensible defaults but it is also highly configurable.
.IP "\(bu" 4
\&\f(CW\*(C`opts\-pre\*(C'\fR
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2020\-2021. Ingy do\*:t Net ingy@ingy.net <mailto:ingy@ingy.net>.
.PP
getopt-bash is released under the \s-1MIT\s0 license.
.PP
See the file License for more details.
